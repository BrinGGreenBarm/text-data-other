어떤 집단이나 일부 국가에서 사람들은
아무 은행 정보 그리고 주민등록번호
같은 암호화된 데이터를 수집하고
있습니다
물론 암호화된이 파일들을 열 순 없죠
보지도 못하는데 이걸 왜 수집하는
걸까요 왜냐하면 10년에서
20년 이내에 양자컴퓨터를 통해
암호화를 해독할 수 있을 거라 믿고
있기 때문이죠 이러한 전력을
stronough decrip
later 일단 저장하고 나중에
해독한다는
줄여서 sntl이라고 부릅니다
산업연구
재약연구 1급 비밀정보와 같이 10년
후에도 여전히 가치가 있을 수 있는
그런 정보들을 계속해서 저장해 나가고
있습니다 미국 국가안보국에서도
충분히 큰 양자컴퓨터가 만들어진다면
공개키 알고리즘을 약화시킬 수 있다고
공표한 적 있죠
미국
국회에서는 모든 기관들의 안무와
방식을 양자컴퓨터로 깨뜨릴 수 없는
방법으로 바꿔야 한다는 법안이
통과되었습니다
지금도 사용되고 있는 현재
암호화 체계는
매우 성공적이었습니다
지난 40년 동안 효율적으로 사용됐죠
1970년대까지만 해도 누군가와
사적인 정보를 교환하려고 하면
직접 만나서 비밀키를 서로 공유해야
했습니다
키로 메시지를 암호화하고 해독하는데
사용했죠 이런 방식을 대칭키
알고리즘이라고 합니다 공유한 키가
유출되지 않는 이상 주고받은 메시지는
안전할 겁니다 하지만
맨날 만나서 키를 주고받을 순
없잖아요 한 번도 만난 적 없는
사람에게 뭔가 알려주고 싶을 수도
있고요
그렇다고이 키를 전화선이나 편지 같은
보안이 없는 채널을 사용해 전달하면
중간에서 누가 쓱 가져가기 너무 쉬울
겁니다 그래서 1977년
라이베스트
샤미르 애들못이 세 명의 과학자들이
새로운 암호화 알고리즘을 만들어냈죠
이게 바로 한번쯤 들어보셨을 수도
있는
RSA 암호화입니다
어떤 방식이냐면 두 사람이 각각 아주
큰 소수를 가지고 있고이 소수는
비밀로 합니다이 두 수를 곱해서 더
큰 숫자를 만들어낸 다음이를 공개
키로 사용하죠
이 숫자는 모든 사람들이 볼 수
있습니다 이제 만약 누군가가
암호화된 메시지를 전달하고 싶을 때
상대방의 공기 키를 사용해 내
메시지를 암호화 시키면 됩니다
공개키를 구성하는 두 가지 주요
소스를 알지 못하면 해독할 수 없는
방식으로 메시지를 암호화하죠 그래서
이걸 비대칭 키 암호화라고 합니다
아무 할 때와 해독할 때 사용되는
키가 다르기 때문이죠이 방식을
사용하면 이미 소스를 하나 알고 있는
상대편의 해독하기 쉽지만
다른 사람의 경우 매우 큰 공개 키를
인수분해하지 않으면 배독할 수 없는
겁니다
일반적인
컴퓨터에는 하나의 비트가 한 번에
하나의 상태 즉
0 또는 1로 있을 수 있습니다
따라서이 비트의 경우에는 4가지
상태가 가능하죠
000110 이렇게네
가지요 이걸 10진수로 표현해보면
0123으로 나타낼 수 있습니다
컴퓨터로 7의 n제곱을 계산해 본다고
해볼까요
그러면 한번에 하나의 상태에 대해
계산할 수 있을테니까 이에 대해서는
7의 제곱
49가 나오겠죠
양자컴퓨터는 똑같이
0 또는 1 두 가지 상태를 가지는
큐비트를 가지고 있습니다 하지만 일반
컴퓨터와는 다르게 큐비트는 한번에
하나의 상태에 있을 필요가 없습니다
여러 상태에 대한 임의의 조합
즉 0과 1이 동시에 중첩해 있을 수
있다는 것이죠
동시에 중첩할 수 있다는 것은 두
개의 큐비트가 있을 때
0123이
동시에
존재할 수 있다는 겁니다
0 1 2 3 이걸 가지고 아까 했던
계산을 다시 해보면 4가지 숫자에
대한 계산을 동시에 알 수 있게 되는
거죠 그 결과는 우리가 원하는 답들의
중첩으로 나올 겁니다 1
7 49 그리고 343이죠 만약
여기에
큐비트를 하나 더 추가한다면 가능한
상태의 수는 2배가 됩니다 세계
큐비트로는 8개 상태를 나타낼 수
있으면서 한 번에 8개의 계산을 할
수 있는 거죠 이러한 큐비트를
20개까지 늘리면 무려 100만
가지가 넘는 계산을 한 번에 보실 수
있습니다
서로 다른 결과를 동시에 계산할 수
있다는 거죠
큐비타 300개가 되면 관찰 가능한
우주에 있는 입자보다도 더 많은
상태를 나타낼 수 있게 됩니다
엄청나 보이죠
맞아요 양자컴퓨터는 어마무시합니다
하지만 한 가치를 짚고 넘어가야
합니다 모든 계산들은 중첩 상태에서
이루어지고 그 답도 중첩 상태입니다
그리고이 중첩들을 쉽게 읽을 수 없죠
관측을 하는 순간 중첩된 값들 중
랜덤한 하나의 값만을 얻게 되고
나머지 정보들은 손실됩니다
따라서 양자컴퓨터의 성능을 제대로
활용하기 위해서는 중첩된 상태에서의
우리가 원하는 정보를 정확하게 가진
상태로 변환하는 방법을 만들어야죠
1994년
피터쇼와 돈 코퍼스미스는
양자 프리의 변환 방법을 만들었습니다
이것도 프리의 변환이니까 일반 프리의
변환과 비슷합니다 주기적인 신호가
있는 주파수를 알아낼 수 있죠 뭐
여기까지는 그냥 그럴 거 같죠 하지만
만약 주기적인 상태의 중첩이 존재할
경우 좀 더 구체적으로는 중첩의
상태가 일정한 크기로 분리가 가능한
상태가 있다고 한다면 이러한 상태에서
양자 풀이의 변환을 대입하면 해당
신호의 주파수를 포함하는 상태를 얻을
수 있습니다 그 뒤에 관측을 할 수
있죠
양자 프리의 변환을 사용하면 주기적인
중첩에서 주파수 정보를 추출할 수
있게 되며
매우 유용 정보를 얻을 수 있게
됩니다 자 이제 어떻게 양자컴퓨터가
소수의 곱을 기존 컴퓨터보다 더
빠르게 인수분해할 수 있는지를
알아보죠 먼저 양자컴퓨터가 필요 없을
간단한 예시부터 시작해서 어떻게 양작
컴퓨터가 아주 큰 수도 짧은 시간
안에 계산할 수 있는지 설명해
드리겠습니다 여기 n이라는 숫자가
있습니다 두 개의 소수 p와 q를
곱한 숫자이죠
직관적인 설명을 위해서
n이 77이라고 해보겠습니다
물론 여러분들은 소수 p와 q가 뭔지
대번에 하셨겠지만
잠깐 이걸 모른다고 생각해보죠이
소수가 정말 정말 큰 수라면 알기
매우 힘들 테니까요 자 이제 꿈과
환상의 나라 수학랜드로 떠나볼까요
숫자 n과 약수를 공유하지 않는 숫자
g를 하나 골라보죠이 숫자 g를
계속해서
곱하고 곱하고 곱하게 되면
언젠가는
n의 배수의 1을 더한 값과
같아집니다
즉 g의 R 제곱이
n의 배 더하기 1인
지수 r이 항상 존재한다는 것이죠
한번 해볼까요
77보다 작은 숫자 아무거나 하나
골라보겠습니다
파일로 한번 해 볼까요
8은 77과 약수를 공유하지
않으니까요 만약 n이 엄청나게 큰 두
소수의 곱이라면 n과 약수를 공유하는
공약수를 고르는 것도 힘들 겁니다
이제
팔을 한번 두 번 세 번 그리고네 번
그리고 계속해서 거듭제곱을 한 다음
각 숫자들을 77로 나눕니다 우리가
알고 싶은 건
77회 되는 숫자로 나눴을 때 몫이
아니라 나머지 값이 몇인지 궁금한
거죠 아까 말한 법칙이 맞다면
언젠가는 77로 나눴을 때 나머지가
1이 나올테니까 말이죠 그래서
팔을 77로 나누면 몫이 0 나머지가
8이 나올 거고
64 역시 몫이 0 나머지가 64일
겁니다
512는 77로 나누면 몫이 6
나머지가 50이 나오겠죠
그렇게 쭉 이어나가다 보면 나 머지가
15 43 36 57
71 29 그리고 결국에는 1이
나오게 됩니다
8의 10제곱이 77의 배수의 1을
더한 값이 되는 거죠이 공식을
만족하는 지수 r을 우리는 찾았습니다
그래서이 공식의 대체 n의 인수를
찾는 것과 무슨 상관이 있는 걸까요이
방정식을 재정렬에서 1을 좌변으로
넘기면
좌변을 다음과 같이 분리할 수 있게
됩니다
치수알이 짝수라면 한계 정수와 다른
정수를 곱한 것이
n의 배수와 같게 되는 거죠이 공식과
p 곱하기 q가 n과 같다는 공식과
매우 유사해 보이지 않나요
앤을 구성하는 p와 q가이 공식의
우변에 있기 때문에
좌변에도 피와 q의 무언가 곱해진
형태로 있어야 하겠죠 한마디로 거의
다 온 겁니다 아까 구했었던
g와 r로 한번 돌아가 보죠
우린 지수 r을 구했기 때문에
n과 약수를 공유하고 있는 두 가지
인수들을
찾아낼 수 있는 겁니다
지수 r이 10이었으니
좌변의 두 변은
각각
8의 5제곱 더하기 1인
32,769와
8의 5제곱 빼기 1인 32,767이
됩니다이 두 숫자들은 높은 확률로
n과 인수를 공유하고 있죠 그 인수는
어떻게 찾죠 유클리드 호재법을
사용하면 됩니다
두 숫자가 있을 때 최대공약수를
빨리 찾는 방법은
큰 숫자를
작은 숫자로 나눈 다음 그 나머지를
사용하는 겁니다
여기
32,769와 77회 같은 경우
32,769를 77로 나누면 나머지가
44가 나오죠이 44를 가지고 같은
과정을 반복합니다
77을 44로 나누면 나머지는 33위
나오게 되겠죠 한 번 더 반복하면
44를 33으로 나누면 나머지가
10일이 나오게 되고 33을 10일로
나누게 되면
몫 13 나머지가 0이 됩니다
나머지가 0이 났을 때 바로 그 수가
우리가 알고 싶던 두 숫자의
최대공약수입니다
즉 11은 77과
32,769 두 숫자 간의
최대공약수인 거죠 그리고 계산해 보면
맞습니다 이제 77을 10일로 나누면
다른 소인수인 7을 얻을 수 있겠죠
정리를 한번 해볼까요
숫자 n의 소인수 p와 q를 찾기
위해서는
먼저 숫자 n과 인수가 전혀 겹치지
않는
g라는 잘못된 예측을 해야 됩니다
그런 다음 n의 배수의 1을 더한
값과 같아지는
g의 지수
r을 구해야 되죠 세 번째로
지수 r을 활용해서 n과 인수를
공유하는 두 개의 새로운 숫자를
계산하고 유클리드호제법을 사용해서
n과 해당 숫자 사이의 인수를 찾으면
p와 q를 찾을 수 있게 되죠
일반적인 컴퓨터에서는이 방법이 인수를
구하는 다른 방법들보다 더 빠르진
않습니다 그리고이 방법을 사용하기
위해 꼭 양자컴퓨터가 필요한 건
아니죠 하지만 양자컴퓨터는 두 번째
단계를 훨씬 더 빠르게 계산할 수
있습니다 바로 잘못 추측한 g에
대해서
n의 배수의 1을 더한 값을 찾아주는
지수 r을 찾는 단계죠 우리가 했었던
77의 배수보다 1 더 큰 8의 10
제곱을 찾아낸 과정을 한번 다시
살펴보죠
팔에 10제곱을 넘어서
8의 11제곱 12제곱
그렇게 계속 구하면 77의 나머지가
어떻게 변화하는지 한번 보겠습니다
나머지가
864 50 15 43 36 57
70 29 그리고 다시
1이 나오게 됩니다 나머지는 계속해서
반복되고 반복될 겁니다 팔의 10제곱
이후로 나머지가 1인 지수의 값은
20이고이는 처음으로 나머지가
1이었던 10보다 10 더 큰
숫자이죠
규칙성을 찾으셨다면
8의 30제곱과 8의 40제곱 지수가
10으로 나누어 떨어지는 모든 경우가
77의 배수보다 1 더 큰 값이 나올
거라는 걸 알 수 있습니다 나머지
1만 그런게 아니라
어떤 나머지 값을 골라도 같죠 15를
보면 똑같이 15를 나머지로 가시는
지수는 이전 지수보다 10 더 큰
값입니다 여기서 핵심은
숫자 n의 배수보다 1 더 큰 값을
가지게 되는 지수 r은 하나만 있는
것이 아니며 나머지들의 주기를 잘
살펴보면
다음 지수 알이 어디 있는지 알 수
있다는 겁니다
시각화를 위해서 나머지들을
로그 스케일 그래프로 그려보면 주기가
10으로 반복된다는게 바로 보이죠
쥐를 팔이 아니라 다른 수로 생각했을
수도 있겠죠 15로 해도 반복되는
나머지 역시 다르 하지만 그 나머지가
1인 점은 언제나 존재합니다 그
이유를 아주 간단하면서도 멋지게
설명할 수 있습니다
지수들의 반복을 유심히 보면
321 그리고 그 왼쪽에는
0이 있어야겠죠
어떤 숫자든 g의 영 제곱은 1이기
때문에 주기가 다시 반복되는 시점에서
1은 무조건 등장하게 되는 거죠
재밌지 않나요 이제 양자컴퓨터를
사용해서 두 소수의 곱을
인수분해해보죠 먼저 큐비트들을 두
세트로 나눕니다
첫 번째 세트에서
0과 1 2 3
4
5 6 7 8 그리고 그 너머의
숫자들에 대해서 중첩을 만듭니다
어디까지 가냐고요 무려 10에
1,234 제곱까지 갈 겁니다
엄청난 중첩 향상이지만 우리에게
완벽한 큐비트가 있다고 한다면
4,100개의 큐비트만 있으면 됩니다
몇 번이고 계속해서 나오는 값이죠
앞서 얘기한 앤은 77이고 g가 8인
경우를 대입해서 생각해보면 우리가
책정한 나머지가 15라고 한다면 중첩
상태에서 15라는 값이 가진 항은
여러 개가 존재할 겁니다 아까
보셨듯이 나머지가 같은 항들은 반복될
거니까요 15의 경우
44 24 34번째 이렇게 쭉 나오게
되겠죠이 숫자들은 10만큼씩 증가하며
놀랍게도 11월 숫자는 우리의 공식
g의 R 제곱은
mn + 1에서
r에 맞는 숫자입니다 좀 더
일반적으로 정리하면 나머지를 측정하면
동일한 나머지를 가지는 상태에 중첩만
남게 된다는 겁니다 그리고 이런
상태들의 지수들은 모두 아래 단위로
증가할 것이라는 거죠이 알은 우리가
찾고 있던 숫자고요 나머지들이 모든
상태에 대해서 동일한 값을 가지므로
잠시 옆으로 치워두고 이제 우리에게
주어진 건 규칙적인 주기가 존재하는
중첩 상태입니다 카카는 아래 크기만큼
이웃과 차이가 나죠 이제 양자 풀이의
변한 공식 을이 중첩 상태에 적용하면
자세한 설명 건너뛰고
r분의 1을 포함하는 상태만을 남기게
됩니다 이제 남은 일은이 측정을
수행한 다음 r분a를 반전시켜
r을 구하기만 하면 됩니다
양자컴퓨터가 할 일은 끝났죠
2012년에는
RSA 암호화를 해독하는데 10억
개의 물리적인 큐비트가 필요할
것이라고 추정되었습니다 그리고 5년
뒤 그 숫자는 2억 3천만기로
줄어들었고 2019년에는 더 많은
기술적인 혁신을 거쳐서 2천만
큐비트로 추정치가 떨어졌죠 오늘날에는
얼마나 많은 큐비트들을 보유하고
있을까요
ibm의 양작 컴퓨터는 큐비투수를
그려보면 현재 필요 예상치인
2000만 큐비트 수에는 근접도
못하지만
양자컴퓨터의 발전은 기하급수적으로
발전하고 있습니다이 그래프는 언젠가
맞 닿을 거고 시간 문제일 뿐이죠
그때가 되면
암호가
뚫릴 겁니다
여기에 두 개의 벡터 r1과 R2
벡터가 있습니다이 벡터들의 정수배로
만들 수 있는 점들은 정말 많을
겁니다
r1을 세 번 곱하고 r2를 1을
곱하면 시작점과 끝점 두 개 점은
얻을 수 있죠 이렇게 다양한 상수들을
곱해서 표현할 수 있는 모든 점을
격자라고 부릅니다 이번엔 아무 위치에
있는 점 c를 생각해보죠 저의 목표는
R1 벡터와 R2 벡터의 어떠한
조합이 점씨의 가장 가까운 격자점에
도달할 수 있는지 알아내는 겁니다
화면에 보이는 그림을 보면 그냥
r2로 두 번 아론으로 반대로 두 번
이동하면 되죠
그런데 말입니다 다르게 생긴 두
벡터도 똑같은 격자를 가질 수
있습니다 여기
B1 벡터와
B2 벡터를 예시로 들어볼까요이 두
벡터로도 같은 격자를 만들 수 있죠
다시 같은 질문해볼까요 여기
c의 가장 가까운 격자점에 도달하는
B1 벡터와 B2 벡터의 조합은
무엇일까요
뭔가 느낌이 조금 더 어려워지지
않았나요 왜 그
씨를 향해서 한 번씩 이동할 때마다
가까워지는 방향으로 가야 된다는 것은
쉽게 알 수 있지만 비원과
B2 벡터는 한쪽 방향으로 이동할
때마다 다른 벡터가 반대 방향으로
이동하게 되면서 좀 헷갈리게 됩니다
결과도
지그재그죠
계산을 해보면 시와 가장 가까운 것은
B1 벡터가 8번
B2 벡터가 마이너스 6번을 곱해서
더하면 됩니다 이전보다 조금 어렵긴
한데 사실 조금만 생각하면 여전히
풀기 쉽죠 하지만 2차원을 3차원으로
확장시키면 어떻게 될까요
당연히 훨씬 어려집니다
화면에는 격자점들을 표시해 놨지만
사실 우리에게 주어진 건 그냥
벡터들 뿐이란 걸 잊으시면 안됩니다
시점에 가장 가까운 격자점을 찾으려면
근처에 모든 점들도 찾아야 하죠
반지름이 아닌 원을 이차원에서 한번
생각해 보겠습니다
원 내부에 격자점수는 원의 넓이인
아래 제곱에 비례할 겁니다 3차원이
되면 9가 됐고 아래 세제곱의
비례하게 되겠죠
차원의 수가 증감에 따라서 격자점의
수가 얼마나 증가하는지를 살펴보면
다음과 같습니다
어떤 점으로 가는 가장 가까운
벡터조합 문제는 3차원까지는 일반
컴퓨터로도 매우 쉽게 풀 수 있죠 한
100차원까지도 어떻게 어떻게 풀만
합니다 하지만 미래의 암호화
체계에서는
약 1000개의 차원을 사용할지도
모릅니다
천개의 차원 중 하나에서 올바르다고
생각한 방향으로 나아갔다면
다른 99개의 차원에서는 어쩌면
잘못된 방향으로 이동하는 것일 수도
있죠 한 축의 방향이 맞더라도
나머지는 틀렸을 수도 있다는 겁니다
이렇게 많은 차원에서의 길찾기는
현존하는 가장 강력한 컴퓨터를
사용해도 매우 어렵습니다 좋은
벡터들의 집합을 알지 못한다면 말이죠
좋은 벡터들이 바로 이런 알고리즘이
데이터 암호화의 사용될 수 있는
이유입니다 이해를 위해 2차원으로
돌아가면
각 사람에게 격자를 설명하기 좋은
벡터집합이 있고 이걸 비밀키처럼
비밀로 유지합니다 그리고 어려운
벡터들을 사용해서 공기 키처럼
공개적으로 공유할 겁니다 이제
누군가한테 메시지를 보내고 싶다면
격자에서 한 점을 선택하게 됩니다 한
점이 숫자 7에 해당한다고 가정을
해보죠이 숫자 7을 다른 사람에게
보내고 싶으면이 점에
임의의 노이즈를 추가해서 보내게
됩니다 정확히 7이라는 지점에
위치하는게 아니라 가장 가까운 점을
보내게 됐던 거죠이 메시지를
해독하려면 수신자가 메시지 지점에서
가장 가까운 격자 지점을 파악해야
됩니다
1천개의 차원이라면 좋은 벡터들의
집합을 모르고 있으면 알아내기 매우
어렵죠
따라서 좋은 벡터들의 집합을 비밀키로
가지고 있는 수신자에게는 쉽지만
다른 모든 사람들에게는 어려운 일이
될 겁니다 그리고 현재까지로서는 이
문제는 일반 컴퓨터나 양자컴퓨터
모두에서
풀기 매우 어렵습니다

